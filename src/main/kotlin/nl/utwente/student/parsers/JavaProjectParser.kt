package nl.utwente.student.parsers

import nl.utwente.student.model.Module
import nl.utwente.student.transformers.Java2XMLTransformer
import nl.utwente.student.visitor.java.JavaLexer
import nl.utwente.student.visitor.java.JavaParser
import org.antlr.v4.runtime.*
import org.antlr.v4.runtime.tree.ParseTree
import org.eclipse.jgit.api.Git
import java.io.*
import java.nio.file.Paths.get
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerException
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult


class JavaProjectParser {

    @Throws(RuntimeException::class)
    fun executeWithArgs(args: Array<out String>) {
        if (args.size == 2) {
            when (args[0]) {
                "--path" -> this.executeWithFilePath(args[1])
                "--projectUrl" -> this.executeWithGitHttpUrl(args[1])
                else -> throw RuntimeException("Invalid input")
            }
        }
    }

    @Throws(IOException::class)
    private fun executeWithFilePath(path: String) {
        if (!path.endsWith(".java")) throw IOException("File is not a Java file.")

        val file = get(System.getProperty("user.dir"), path).toFile()
        val parseTree = parseFile(file)

        val modules = runTransformer(parseTree, file)

        modules.parallelStream().forEach { module -> writeToXML(module, this.getOutputFile(module)) }
    }

    private fun executeWithGitHttpUrl(url: String) {
        if (!url.endsWith(".git")) throw IOException("Invalid git repository url")

        // Clone repository via provided url into /input directory
        val repoName = url.split("/").last().dropLast(4)

        val file = get(System.getProperty("user.dir"), "/projects/${repoName}").toFile()

        if (!file.exists()) {
            Git.cloneRepository()
                .setURI(url)
                .setDirectory(file)
                .call()
        }

        // Retrieve all files ending with .java extension
        file.walk()
            .filter { it.isFile && it.name.endsWith(".java") }
            .forEach {
                val parseTree = parseFile(it)

                val modules = runTransformer(parseTree, it)

                // Phase 4: Write documents to files
                modules.parallelStream().forEach { module -> writeToXML(module, this.getProjectOutputFile(module)) }
            }
    }

    private fun parseFile(file: File): ParseTree {
        FileInputStream(file).use {
            val input = CharStreams.fromStream(it)

            // Phase 1: Run the lexer
            val tokens = runLexer(input)

            // Phase 2: Run the parser
            return runParser(tokens)
        }
    }

    /**
     * Take the character input and turn it into tokens according to the grammar.
     *
     * @param input The input.
     * @return A steam of tokens.
     */
    private fun runLexer(input: CharStream): CommonTokenStream {
        return CommonTokenStream(JavaLexer(input))
    }

    /**
     * Tries to form a parse tree from the given tokens. In case of errors, the error listener is
     * called, but the parser still tries to create a parse tree.
     *
     * @param tokens The tokens returned from the lexer.
     * @return A Parse Tree.
     */
    private fun runParser(tokens: CommonTokenStream): ParseTree {
        return JavaParser(tokens).compilationUnit()
    }

    /**
     * Called to check if the source code was semantically correct. This method is only called when
     * there were no syntax errors.
     *
     * @param parseTree The parse tree generated by the parser
     * @return True if all code is semantically correct
     */
    private fun runTransformer(parseTree: ParseTree, file: File): List<Module> {
        val visitor = Java2XMLTransformer(file)
        visitor.visit(parseTree)
        return visitor.documents
    }

    private fun getOutputFile(module: Module): File {
        val fileName = "${module.packageName}.${module.moduleName}.xml";

        val path = get(
            System.getProperty("user.dir"),
            "out",
            "input",
        ).toFile()

        // Make folders if they do not exist yet.
        path.mkdirs()

        return get(path.absolutePath, fileName).toFile()
    }

    private fun getProjectOutputFile(module: Module): File {
        val projectName = module.file.parent.split("LAMP-Framework/projects/")[1].split("/")[0]
        val fileName = "${module.packageName}.${module.moduleName}.xml";

        val path = get(
            System.getProperty("user.dir"),
            "out",
            projectName
        ).toFile()

        // Make folders if they do not exist yet.
        path.mkdirs();

        return get(path.absolutePath, fileName).toFile()
    }

    private fun writeToXML(module: Module, toFile: File) {
        val transformerFactory = TransformerFactory.newInstance()
        val transformer = transformerFactory.newTransformer()

        transformer.setOutputProperty(OutputKeys.INDENT, "yes")
        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4")
        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes")

        val source = DOMSource(module.moduleDocument)

        try {


            FileWriter(
                toFile
            ).use { writer ->
                val result = StreamResult(writer)
                transformer.transform(source, result)
            }
        } catch (e: TransformerException) {
            throw RuntimeException(e)
        }
    }
}